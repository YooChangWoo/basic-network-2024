# basic-network-2024
2024년 IoT개발자과정 네트워크 통신 리포지토리


## 1일차

- 리눅스
    - 파일 입출력(LOW-level File Access)
    - 파일 디스크립터(File Descriptor)
    - 파일 열기 (open)
        - path : 파일 이름을 나타내는 문자열의 주소 값 전달.
        - flag : 파일의 오픈 모드 정보 전달
    
    - 파일 닫기 (close)
        - fd : 닫고자 하는 파일 또는 소켓의 파일 디스크립터 전달.

    - 파일에 데이터 쓰기 (writh)
        - fd : 데이터 전송대상을 나타내는 파일 디스크립터 전달.
        - buf : 전송할 데이터가 저장된 버퍼의 주소 값 전달.
        - nbytes : 전송할 데이터의 파이트 수 전달.

    - 파일에 저장된 데이터 읽기(read)
        - fd : 데이터 수신대상을 나타내는 파일 디스크립터 전달
        - buf : 수신한 데이터를 저장할 버퍼의 주소 값 전달
        - nbytes : 수신할 최대 바이트 수 전달

- 프로토콜
    - 소켓의 생성
        - domain : 소켓이 사용할 프로토콜 체계(Protocol Family)정보 전달
        - type : 소켓의 데이터 전송방식에 대한 정보 전달.
        - protocol : 두컴퓨터간 통신에 사용되는 프로토콜 정보 전달

    - 프로토콜 체계
        - PF-INET : IPv4 인터넷프로토콜 체계
        - PF_INET6 : IPV6 인터넷 프로토콜 체계
        - PF_LOCAL : 로컬 통신을 위한 UNIX 프로토콜 체계
        - PF_PACKET : Low Level 소켓을 위한 프로토콜 체계
        - PF_IPX : IPX 노벨 프로토콜 체계

    - 소켓의 타입
        - 연결지향형 소켓(TCP) 
            - 중간에 데이터가 소멸되지 않는다.
            - 전송 순서대로 데이터가 수신된다.
            - 전송되는 데이터의 경계(Boundary)가 존재하지 않는다. 

        - 비 연결지향형 소켓 (UDP)
            - 전송된 순서에 상관없이 가장 빠르게 전송을 지향한다.
            - 전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다.
            - 전송되는 데이터의 경계(Boundary)가 존재한다.
            - 한번에 전송할 수 있는 데이터의 크기가 제한된다.

    - IP주소와 PORT번호
        - 인터넷 주소(Inernet Address)
            - IPv4(Internet Protocol version4)  4바이트 주소체계
            - IPv6(Internet Protocol version6)  16바이트 주소체계

    - 클래스 별 네트워크 주소와 호스트 주소의 경계
        - 클래스 A의 첫 번째 바이트 범위 : 0이상 127이하  /  첫 번째 빝트는 항상 0으로 시작
        - 클래스 B의 첫 번째 바이트 범위 : 128이상 191이하  /  첫 두 비트는 항상 10으로 시작
        - 클래스 C의 첫 번째 바이트 범위 : 192이상 233이하  /  첫 세비트는 항상 110으로 시작

    - 주소정보의 표현
        - POSIX(Portable Operating System Interface)은 이식 가능한 운영 체제 인터페이스의 약자로,
          UNIX 운영 체제 호환성을 위한 표준 규격을 정의한 것입니다.
          POSIX는 다양한 운영 체제 간의 호환성을 보장하기 위해 IEEE가 개발했으며,
          다음과 같은 주요 구성 요소를 포함합니다:

        - 파일 시스템: 파일 및 디렉터리 조작에 관한 표준 인터페이스.
        - 프로세스 관리: 프로세스 생성, 제어, 종료 등에 관한 인터페이스.
        - 스레드: 멀티스레딩을 지원하기 위한 표준 인터페이스.
        - 입출력(I/O): 파일, 장치, 네트워크 소켓 등의 입출력 처리를 위한 표준 규격.
        - 유틸리티: 쉘 및 명령어 인터프리터, 시스템 명령어 및 유틸리티의 표준.

    - 구조체 sockaddr_in 멤버
        - 멤버 sin_family
            - AF_INET : IPv4 인터넷 프로토콜에 적용하는 주소체계
            - AF_INET6 : IPv6 인터넷 프로토콜에 적용하는 주소체계
            - AF_LOCAL : 로컬 통신을 위한 유닉스 프로토콜의 주소체계

        - 멤버 sin_port : 16비트 PORT번호 저장 / PORT 번호를 저장한다는 사실 보다 네트워크 바이트 
                          순서로 저장해야 한다는 사실이 더 중요하다.
        - 멤버 sin_addr : 32비트 IP주소정보 저장 / 네트워크 바이트 순서대로 저장하며 구조체 
                          in_addr도 함께 살펴봐야 한다.
        - 멤버 sin_zero : 구조체(struct sockaddr_in)에서 사용되는 멤버입니다. 이 멤버는 구조체의 
                          크기를 다른 주소 구조체와 맞추기 위해 사용되는 패딩 공간으로,
                          실제 데이터는 포함되지 않고 sin_zero는 보통 8바이트 크기의 배열임, 반드시 0으로 채워야 함.

    - 바이트 순서 변환 메모
        - 빅 엔디안 (Big Endian) : 높은 자리 바이트가 낮은 메모리 주소에 저장
            - 예: 0x12345678 저장
        ```
           주소:  |  값:
           -------|-------
             0    |  0x12
             1    |  0x34
             2    |  0x56
             3    |  0x78
        ```

        - 리틀 엔디안 (Little Endian) : 낮은 자리 바이트가 낮은 메모리 주소에 저장
            - 예: 0x12345678 저장

        ```
            주소:  |  값:
            -------|-------
              0    |  0x78
              1    |  0x56
              2    |  0x34
              3    |  0x12
        ```

        - 빅 엔디안 → 리틀 엔디안 : 0x12345678 -> 0x78563412
        - 리틀 엔디안 → 빅 엔디안 : 0x78563412 -> 0x12345678
        - 리틀 엔디안에서 빅 엔디안
        ```
            uint32_t little_to_big(uint32_t val) {
                return ((val & 0x000000FF) << 24) |
                       ((val & 0x0000FF00) << 8)  |
                       ((val & 0x00FF0000) >> 8)  |
                       ((val & 0xFF000000) >> 24);
            }
        ```
        - 빅 엔디안에서 리틀 엔디안
        ```
            uint32_t big_to_little(uint32_t val) {
                return ((val & 0x000000FF) << 24) |
                       ((val & 0x0000FF00) << 8)  |
                       ((val & 0x00FF0000) >> 8)  |
                       ((val & 0xFF000000) >> 24);
            }
        ```

## 2일차

- 인터넷 주소의 초기화

    - 구조체 설정: 주소 정보를 저장하기 위한 struct sockaddr_in 구조체를 선언합니다.
    - 주소 체계 설정: sin_family 멤버를 AF_INET으로 설정하여 IPv4를 사용함을 명시합니다.
    - 포트 설정: sin_port 멤버에 사용할 포트 번호를 설정합니다. 네트워크 바이트 순서로 설정해야 하므로 htons() 함수를 사용하여 변환합니다.
    - IP 주소 설정: sin_addr.s_addr 멤버에 서버의 IP 주소를 설정합니다.
      일반적으로 문자열 형태의 IP 주소를 inet_addr() 함수를 사용하여 이진 형태로 변환하여 설정합니다.

- 클라이언트의 주소정보 초기화
    - 구조체 설정: 주소 정보를 저장하기 위한 struct sockaddr_in 구조체를 선언합니다.
    - 주소 체계 설정: sin_family 멤버를 AF_INET으로 설정하여 IPv4를 사용함을 명시합니다.
    - 포트 설정: sin_port 멤버에 서버의 포트 번호를 설정합니다. 네트워크 바이트 순서로 설정해야 하므로 htons() 함수를 사용하여 변환합니다.
    - IP 주소 설정: sin_addr.s_addr 멤버에 서버의 IP 주소를 설정합니다. 일반적으로는 서버의 IP 주소를 문자열 형태로 설정하고,
      이를 inet_addr() 함수를 사용하여 이진 형태로 변환하여 설정합니다.

- INADDR_ANY
    - 서버의 IP 주소 설정: INADDR_ANY를 사용하면 서버 소켓이 시스템의 모든 네트워크 인터페이스로부터 클라이언트의 연결을 수락할 수 있습니다.
    - 클라이언트의 IP 주소 설정: 일반적으로 클라이언트는 서버의 IP 주소를 명시적으로 설정하지 않습니다.

    - 예를 들어, 서버 소켓을 바인딩할 때 INADDR_ANY를 사용하는 경우:
    ```
        server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    ```

-  소켓에 인터넷 주소 할당하기
    - 소켓 생성: 먼저 소켓을 생성합니다. 이때, socket() 함수를 사용하고 소켓의 유형과 프로토콜을 지정합니다.
    - 주소 설정: 주소 정보를 저장할 struct sockaddr_in 구조체를 생성하고, 주소 체계, IP 주소, 포트 번호를 설정합니다.
    - 바인딩: bind() 함수를 사용하여 소켓에 주소를 할당합니다. 이때, 소켓 디스크립터와 주소 정보를 전달합니다.

- TCP/IP 프로토콜 스택 : TCP/IP 프로토콜 스택은 일반적으로 네트워크 계층 모델을 따르며, 여러 계층으로 구성됩니다.
                        가장 일반적으로 사용되는 모델은 OSI 모델과 유사하지만 약간 다를 수 있습니다. 주요 계층은 다음과 같습니다:
    - LINK 계층 (또는 네트워크 인터페이스 계층):

        - 역할: 물리적 네트워크에 데이터를 전송하고 수신합니다.
        - 기능: 이더넷, Wi-Fi 등과 같은 물리적 네트워크 인터페이스를 제어하고, 데이터 프레임을 생성하고 해석합니다.
        - 예시: 이더넷 프레임을 생성하고 물리적 네트워크에 전송하는 것.
        
    - IP 계층 (인터넷 계층):

        - 역할: 호스트 간의 패킷 전달을 담당합니다.
        - 기능: IP 주소를 사용하여 패킷의 출발지와 목적지를 식별하고, 라우팅을 수행합니다.
        - 예시: IP 주소를 기반으로 패킷을 라우팅하고, ICMP (인터넷 제어 메시지 프로토콜)를 사용하여 네트워크 상태를 확인합니다.
        
    - TCP/UDP 계층 (전송 계층):

        - 역할: 종단간 통신을 제공합니다.
        - 기능: TCP (전송 제어 프로토콜): 연결 지향적 통신을 제공하며, 데이터 전송의 신뢰성을 보장합니다.
                UDP (사용자 데이터그램 프로토콜): 비연결성, 비신뢰성 프로토콜로, 데이터 전송 속도가 중요할 때 사용됩니다.
        - 예시: TCP는 웹 브라우징, 파일 전송 등에 사용되고, UDP는 실시간 동영상 스트리밍, DNS 등에 사용됩니다.
        
    - APPLICATION 계층:

        - 역할: 사용자 애플리케이션과 네트워크 서비스 간의 상호 작용을 지원합니다.
        - 기능: 다양한 프로토콜과 서비스를 제공하며, 이메일, 웹 브라우징, 파일 전송 등을 포함합니다.
        - 예시: HTTP, FTP, SMTP, DNS 등의 프로토콜이 여기에 속합니다.
        - 이러한 계층 구조를 통해 TCP/IP 프로토콜 스택은 네트워크 통신을 효율적으로 관리하고, 다양한 서비스를 제공할 수 있습니다.

- TCP 서버에서의 기본적인 함수호출 순서
    - 1. 소켓 생성 (Socket Creation)
    - 2. 주소와 포트 바인딩 (Binding Address and Port)
    - 3. 연결 수신 대기 (Listening for Connections)
    - 4. 연결 수락 (Accepting Connections)
    - 5. 데이터 통신 (Data Communication)
    - 6. 연결 종료 (Closing Connection)

- 연결요청 대기상태로의 진입
    ```
        #include <sys/socket.h>

        int listen(int sockfd, int backlog);
    ```
    - sockfd: 연결 요청을 대기할 서버 소켓의 파일 디스크립터입니다. 이 소켓은 bind() 함수를 사용하여 주소와 포트를 바인딩한 후에 호출되어야 합니다.
    - backlog: 대기 큐의 최대 길이를 나타내는 매개변수입니다. 대기 큐는 연결 요청을 수락하기 전에 대기하는 클라이언트의 최대 수를 결정합니다.

- 클라이언트의 연결요청 수락
    ```
    #include <sys/socket.h>
    #include <netinet/in.h>

    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    ```
    - sockfd: 서버 소켓을 가리키는 파일 디스크립터입니다. 이 소켓은 bind() 및 listen() 함수로 설정되어야 합니다.
    - addr: 클라이언트의 주소 정보를 저장할 구조체의 포인터입니다. 연결된 클라이언트의 주소 정보가 여기에 저장됩니다.
    - addrlen: addr 구조체의 크기를 나타내는 포인터입니다. 함수가 호출되기 전에 이 값은 클라이언트 주소 구조체의 크기로 초기화되어야 합니다.

- TCP 클라이언트의 본적인 함수호출 순서
    - 1. 소켓 생성 (Socket Creation)
    - 2. 서버에 연결 (Connect to Server)
    - 3. 데이터 통신 (Data Communication)
    - 4. 연결 종료 (Closing Connection):
    ```
        #include <sys/socket.h>

        int listen(int sockfd, int backlog);
    ```
    - sockfd: 연결 요청을 대기할 서버 소켓의 파일 디스크립터입니다. 이 소켓은 bind() 함수를 사용하여 주소와 포트를 바인딩한 후에 호출되어야 합니다.
    - backlog: 대기 큐의 최대 길이를 나타내는 매개변수입니다. 대기 큐는 연결 요청을 수락하기 전에 대기하는 클라이언트의 최대 수를 결정합니다.

- TCP기반 서버, 클라이언트의 함수호출 관계
    - 서버 (Server):
        - 서버는 먼저 소켓을 생성하고, 주소와 포트를 바인딩합니다. 이는 socket() 및 bind() 함수를 사용하여 이루어집니다.
        - 그 후, 서버는 클라이언트의 연결 요청을 수락하기 위해 listen() 함수를 호출하여 대기 모드로 진입합니다.
        - 클라이언트의 연결 요청이 수신되면, accept() 함수를 호출하여 해당 클라이언트와의 통신을 위한 새로운 소켓을 생성합니다.
        - 이후 생성된 소켓을 통해 클라이언트와 데이터를 주고받습니다.
    - 클라이언트 (Client):
        - 클라이언트는 먼저 소켓을 생성하고, 서버에 연결하기 위해 connect() 함수를 호출합니다.
        - 서버에 연결되면, 클라이언트는 send() 함수를 사용하여 서버로 데이터를 전송하고, recv() 함수를 사용하여 서버로부터 데이터를 수신합니다.
        - 통신이 완료되면, 클라이언트는 close() 함수를 호출하여 소켓을 닫습니다.

- ITERATIVE 서버를 구현

    - 소켓 생성 (Socket Creation):
        - 서버 소켓을 생성합니다. 이 소켓은 클라이언트의 연결 요청을 수락하는 데 사용됩니다.
        
    - 주소와 포트 바인딩 (Binding Address and Port):
        - 서버 소켓에 IP 주소와 포트 번호를 바인딩합니다. 이를 통해 클라이언트가 서버에 연결할 수 있게 됩니다.
    
    - 연결 요청 대기 (Listening for Connections):
        - listen() 함수를 호출하여 클라이언트의 연결 요청을 수락할 준비를 합니다.
    
    - 클라이언트의 연결 요청 수락 (Accepting Client Connections):
        - accept() 함수를 사용하여 클라이언트의 연결 요청을 수락하고, 새로운 클라이언트와 통신할 소켓을 생성합니다.
    
    - 데이터 통신 (Data Communication):
        - 클라이언트와 서버 간의 데이터 통신을 수행합니다. 이 때, 클라이언트와의 통신을 위한 새로운 스레드 또는 프로세스를 생성하지 않고, 현재 스레드 또는 프로세스에서 처리합니다.
    
    - 연결 종료 (Closing Connection):
        - 클라이언트와의 통신이 완료되면 생성된 클라이언트 소켓을 닫습니다.

- Iterative 에코 서버, 에코 클라이언트 : 에코 서버 및 클라이언트는 클라이언트가 서버로 메시지를 보내면 서버가 동일한 메시지를 클라이언트에게 다시 보내는 간단한 통신 모델

    - 에코 서버의 구현:

        - 소켓 생성 및 바인딩: 서버는 소켓을 생성하고, 클라이언트의 연결 요청을 받을 준비를 합니다.
        주소와 포트를 바인딩하여 클라이언트의 연결을 받을 수 있게 합니다.
        - 연결 요청 대기: 서버는 클라이언트의 연결 요청을 대기합니다.
        - 클라이언트의 연결 수락: 클라이언트가 연결되면, 서버는 클라이언트와의 통신을 위한 소켓을 생성합니다.
        - 데이터 수신 및 송신: 클라이언트로부터 메시지를 수신하고, 수신한 메시지를 그대로 다시 클라이언트에게 송신합니다.
        - 연결 종료: 통신이 완료되면 클라이언트와의 연결을 종료합니다.

    - 에코 클라이언트의 구현:

        - 소켓 생성 및 서버 연결: 클라이언트는 소켓을 생성하고, 서버에 연결합니다.
        - 메시지 전송: 클라이언트는 서버에 메시지를 전송합니다.
        - 서버로부터의 응답 수신: 서버로부터 동일한 메시지를 다시 수신합니다.
        - 연결 종료: 통신이 완료되면 서버와의 연결을 종료합니다.

- 에코 클라이언트의 문제점
    - 서버 응답 지연: 서버가 응답을 제때에 보내지 않을 경우 클라이언트는 블록될 수 있습니다.
    - 메시지 크기 제한: 클라이언트 및 서버의 메시지 크기가 버퍼 크기를 초과할 경우 데이터 손실이 발생할 수 있습니다.
    - 연결 끊김 처리 부족: 서버와의 연결이 갑자기 끊길 경우 클라이언트가 이를 처리하는 방법이 없을 수 있습니다.
    - 에러 처리 부족: 네트워크 통신 중 발생할 수 있는 다양한 에러에 대한 처리가 충분하지 않을 수 있습니다.
    - 다중 클라이언트 처리 문제: 현재 구현은 단일 클라이언트와의 통신만을 다룹니다. 다중 클라이언트를 처리하려면 별도의 방법이 필요합니다.
    - 보안 취약점: 현재 구현에서는 보안을 고려하지 않고 있으며, 암호화 및 인증 등의 보안 기능이 없습니다.
    - 오류 처리 부재: 클라이언트가 서버와의 통신 중 오류 발생 시 적절한 오류 처리가 부재할 수 있습니다. 이로 인해 예기치 않은 동작이 발생할 수 있습니다.

- 에코 클라이언트의 해결책
    - 클라이언트가 수신해야 할 데이터의 크기를 미리 알고 있기 때문에 예를 들어서 크기가 20바이트인 문자열을 전송했다면, 20바이트를 수신할 때까지 반복해서 read 함수를 호출하면 된다.

- 계산기 서버, 클라이언트의 예
    - 클라이언트는 서버에 접속하자마자 피연산자의 개수정보를 1바이트 정수형태로 전달한다.
    - 클라이언트가 서버에 전달하는 정수 하나는 4바이트로 표현한다.
    - 정수를 전달한 다음에는 연산의 종류를 전달한다. 연산정보는 1바이트로 전달한다.
    - 문자 +,-,* 중 하나를 선택해서 전달한다.
    - 서버는 연산결과를 4바이트 정수의 형태로 클라이언트에게 전달한다.
    - 연산결과를 얻은 클라이언트는 서버와의 연결을 종료한다.

- TCP 소켓에 존재하는 입출력 버퍼
    - 입력 버퍼
        - TCP 소켓의 입력 버퍼는 클라이언트가 서버로부터 데이터를 수신할 때 사용됩니다.
        - 클라이언트가 데이터를 수신하면, 해당 데이터는 먼저 입력 버퍼에 저장됩니다.
        - 클라이언트가 데이터를 읽을 때, 소켓으로부터 데이터를 읽어올 때마다 버퍼에서 데이터가 제거됩니다.

    - 출력 버퍼
        - TCP 소켓의 출력 버퍼는 클라이언트가 서버로 데이터를 전송할 때 사용됩니다.
        - 클라이언트가 데이터를 소켓으로 전송하면, 해당 데이터는 먼저 출력 버퍼에 저장됩니다.
        - 데이터가 실제로 네트워크로 전송되기 전에 출력 버퍼에 쌓여 있는 데이터가 소켓을 통해 전송됩니다.

- TCP의 내부 동작원리1: 상대 소켓과의 연결
    - 연결 요청 (Connection Request): TCP 클라이언트가 서버에 연결을 요청합니다. 이 요청은 클라이언트의 소켓에서 생성된 SYN 패킷을 서버의 IP 주소와 포트 번호로 전송하여 수행됩니다.
    - 연결 수락 (Connection Acceptance): 서버는 클라이언트의 연결 요청을 수신하고, SYN 패킷에 대한 응답으로 ACK와 SYN를 함께 보내는 SYN-ACK 패킷을 클라이언트에게 전송합니다.
    - 연결 확인 (Connection Establishment): 클라이언트는 서버로부터 받은 SYN-ACK 패킷에 대한 확인 응답으로 ACK 패킷을 보냅니다. 이로써 연결이 설정됩니다.
    - 연결 설정 완료 (Connection Established): 클라이언트와 서버 모두가 서로의 ACK 패킷을 수신하면 연결이 설정됩니다. 이후부터 양쪽 소켓 간에 데이터 전송이 가능해집니다.

- TCP의 내부 동작원리2: 상대 소켓과의 데이터 송수신
    - 데이터 전송 (Data Transmission): 데이터를 전송하려는 소켓은 TCP 세그먼트를 생성하여 상대 소켓으로 전송합니다. TCP 세그먼트에는 데이터와 제어 정보가 포함됩니다.
    - 데이터 수신 (Data Reception): 상대 소켓은 TCP 세그먼트를 수신하고, 세그먼트의 내용을 추출하여 상위 계층에 전달합니다.
    - 흐름 제어 (Flow Control): 데이터 송수신 과정에서 TCP는 흐름 제어를 수행하여 수신 측의 버퍼 오버플로우를 방지합니다. 수신 측은 수신할 수 있는 양 이상의 데이터를 보내지 않도록 송신 측에게 알려줍니다.
    - 순서 보장 (Sequence Control): TCP는 데이터를 순서대로 전송하기 위해 시퀀스 번호를 사용합니다. 수신 측은 시퀀스 번호를 통해 데이터의 순서를 파악하고 필요한 경우 데이터를 재조립합니다.
    - 신뢰성 보장 (Reliability Assurance): 데이터 전송 과정에서 TCP는 신뢰성 있는 전송을 보장하기 위해 재전송 메커니즘을 사용합니다. 데이터가 손실되거나 손상되면 TCP는 해당 데이터를 다시 전송합니다.

- TCP의 내부 동작원리3: 상대 소켓과의 연결종료
    - 연결 종료 요청 (Connection Termination Request): 어느 한 측이 연결을 종료하고자 할 때, 해당 측은 상대 측에게 연결 종료를 요청하는 FIN 패킷을 전송합니다.
    - 연결 종료 응답 (Connection Termination Response): 상대 측은 FIN 패킷을 수신하면 연결 종료를 승인하는 ACK 패킷을 전송합니다. 이때, 자신도 연결을 종료하고자 한다면 자신의 FIN 패킷도 함께 전송합니다.
    - 연결 종료 확인 (Connection Termination Acknowledgement): 종료 요청을 보낸 측은 상대 측의 ACK 패킷을 수신하면 연결이 정상적으로 종료되었다고 확인하고, 연결 종료를 완료합니다.
    - 연결 종료 완료 (Connection Termination Completion): 양쪽 측이 서로의 FIN 패킷에 대한 ACK 패킷을 수신하면 연결이 완전히 종료됩니다.

- UDP 소켓의 특성
    - 비연결성 (Connectionless): UDP는 연결 설정 과정이 없이 데이터를 주고받습니다. 따라서 TCP와는 달리 연결을 설정하고 해제하는 과정이 없습니다.
    - 신뢰성 없음 (Unreliable): UDP는 데이터 전송 시 신뢰성을 보장하지 않습니다. 데이터 전송 중 손실이나 손상이 발생할 수 있으며, 이를 처리하기 위한 재전송이나 흐름 제어 기능이 없습니다.
    - 흐름 제어 없음 (No Flow Control): TCP와 달리 UDP는 흐름 제어 기능이 없습니다. 따라서 데이터를 수신할 수 있는 속도를 조절할 수 없으며, 수신 측의 버퍼 오버플로우를 방지할 수 있는 방법이 없습니다.
    - 순서 보장 없음 (No Sequencing): UDP는 데이터를 순서대로 전송하지 않습니다. 따라서 데이터가 도착하는 순서가 전송한 순서와 일치하지 않을 수 있습니다.
    - 작은 헤더 오버헤드 (Small Header Overhead): UDP 헤더는 TCP보다 훨씬 간단합니다. 이는 추가적인 오버헤드가 적기 때문에 데이터 전송에 있어서 더 효율적입니다.
    - 빠른 전송 속도 (Fast Transmission Speed): TCP보다 빠른 전송 속도를 가집니다. 연결 설정 및 흐름 제어 기능이 없기 때문에 데이터 전송이 더 빠릅니다.
